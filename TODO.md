関数呼び出しのたびに関数全体をcloneするという非常に雑な実装になっている。
正しくは、関数データは別に持っておいて、そこへの参照を環境に格納するというふうにして、mutable referenceの問題を解決できるはず
とりあえずローカルで関数オブジェクトが新たに生成されることは無いので、globalな関数オブジェクトのリファレンスを持っておけばいけるはず
オブジェクトの場合はローカルでも生成されて、さらに返却されることもあるので、GCの実装が必要になる

rust_testでも同じようなことをした。
&'i のように参照にlifetime parameterを付ける

ブラウザ組み込みだと、JSオブジェクトとのinterop的なことも必要になりそう


## OLD
結局文法にASTの生成を組み込んだほうが楽にできそう.
listenerでいろいろするのは大変と思われる.
C#とかJavaではenumが無いのでやむを得ずそうしていたに過ぎない



Stringをborrowしたのがstr&, Stringをderefするとstrになる
entryでcurrent levelを下げる、exitで戻せばよい

文法のライセンスはGPLなので、全体のライセンスもGPLにならざるを得ない

* Antlrの使い方を学習、Rustの使い方も
  * Listener vs Visitor
    * https://saumitra.me/blog/antlr4-visitor-vs-listener-pattern/
* VBAの文法を使う
* Rubberduckを参考にして、構文解析結果をASTにする
* インタプリタの実装

自動生成の規則
分岐や組み合わせが無い: 何も作らない
組み合わせ: 分解. ?は、数で調べる（？と、使う記号に対する+や*は同時にできない）。+は、数と動的型（この精査？）。
OR... 各ORで名前を付ける。それが不要ということは、同じ型になるもの。

記号と

生成規則を横に書いてもいい気がする？でもDSLが必要で複雑になりそう。
ある部分が存在しないときは、特別な扱いをする（デフォルト値、Option、空配列）みたいなものを書けるように

使う記号: ID, NUM, opなど

antlrをパースするAntlrみたいな感じになる

$nは適切なものに置換される？
ASTの型($1, $2, $3)
inner or

というはantlrがデフォルトのやつと同様。moveすることでいい感じになる
